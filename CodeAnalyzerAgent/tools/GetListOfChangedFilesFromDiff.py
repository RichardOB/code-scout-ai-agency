from agency_swarm.tools import BaseTool
from pydantic import Field

from clients.bitbucket_client import BitbucketClient
from utils.code_parser_utility import get_changed_files


class GetListOfChangedFilesFromDiff(BaseTool):
    """
    This tool extracts a list of the paths of changed files from a Bitbucket Diff.
    """

    bitbucket_diff: str = Field(
        ..., description="The code_changes diff string returned from the Bitbucket API when fetching a pull request."
    )

    def run(self):
        changed_files = get_changed_files(self.bitbucket_diff)
        return {
            "paths_of_changed_files": changed_files
        }


# if __name__ == "__main__":
#     diff_string = "diff --git a/chatbot_service/database/models/employee_notification_model.py b/chatbot_service/database/models/employee_notification_model.py\nindex 70c73ec..21a3671 100644\n--- a/chatbot_service/database/models/employee_notification_model.py\n+++ b/chatbot_service/database/models/employee_notification_model.py\n@@ -1,4 +1,4 @@\n-from typing import Optional\n+from typing import Optional, List\n from database.database import Base, database_connection\n \n from sqlalchemy import (\n@@ -19,6 +19,11 @@ class EmployeeNotificationsFilter:\n         self.query = self.query.filter_by(employee_id=employee_id)\n         return self\n \n+    def for_reference_id(self, reference_id):\n+        \"\"\"Filter notifications by reference_id\"\"\"\n+        self.query = self.query.filter_by(reference_id=str(reference_id))\n+        return self\n+\n     def unread_only(self):\n         \"\"\"Filter for unread notifications\"\"\"\n         self.query = self.query.filter_by(date_notification_viewed=None)\n@@ -98,6 +103,29 @@ class EmployeeNotification(Base):\n         \"\"\"\n         return database_connection.query(EmployeeNotification).get(notification_id)\n \n+\n+    @staticmethod\n+    def get_notifications_by_reference_id(\n+        reference_id: str,\n+        include_read: bool = True\n+    ) -> List[\"EmployeeNotification\"]:\n+        \"\"\"\n+        Get notification by reference id\n+        Args:\n+            reference_id (str): Reference id to filter notifications by\n+            include_read (bool, optional): Whether to include already read notifications.\n+                Defaults to True.\n+        \n+        Returns:\n+            List[EmployeeNotification]: List of matching notification objects\n+        \"\"\"\n+        query = EmployeeNotification.filter().for_reference_id(reference_id)\n+\n+        if not include_read:\n+            query = query.unread_only()\n+        \n+        return query.execute()\n+\n     def mark_as_viewed(self):\n         \"\"\"\n         Mark the notification as viewed by setting date_notification_viewed\n@@ -106,7 +134,39 @@ class EmployeeNotification(Base):\n         if self.date_notification_viewed is None:\n             self.date_notification_viewed = get_current_utc_time()\n             database_connection.add(self)\n-            database_connection.commit()\n+            database_connection.commit() \n+\n+    @staticmethod\n+    def mark_notifications_by_reference_id_as_viewed(reference_id: str):\n+        \"\"\"\n+        Mark all unread notifications with the specified reference_id as viewed.\n+\n+        This method retrieves all unread notifications matching the given reference_id\n+        and marks them as viewed by setting their date_notification_viewed to the current\n+        UTC time. The changes are committed to the database in a single transaction.\n+\n+        Args:\n+            reference_id (str): The reference ID to filter notifications by\n+\n+        Note:\n+            - Only unread notifications (where date_notification_viewed is None) are affected\n+            - If no matching unread notifications are found, the method returns without making any changes\n+            - All matching notifications are updated with the same view timestamp\n+        \"\"\"\n+        notifications = EmployeeNotification.get_notifications_by_reference_id(\n+            reference_id=reference_id,\n+            include_read=False\n+        )\n+        \n+        if not notifications:\n+            return\n+            \n+        current_time = get_current_utc_time()\n+        for notification in notifications:\n+            notification.date_notification_viewed = current_time\n+            \n+        database_connection.add_all(notifications)\n+        database_connection.commit()\n \n     @staticmethod\n     def handle_notification_send_trigger(employee_notification_id: int, employee_id: int):\ndiff --git a/chatbot_service/database/models/employee_ticket_model.py b/chatbot_service/database/models/employee_ticket_model.py\nindex 3bd5f24..cbe7c2e 100644\n--- a/chatbot_service/database/models/employee_ticket_model.py\n+++ b/chatbot_service/database/models/employee_ticket_model.py\n@@ -125,3 +125,10 @@ class EmployeeTicket(Base):\n         query = query.order_by(EmployeeTicket.date_created.desc()).limit(limit)\n \n         return query.all()\n+\n+    def mark_ticket_notifications_as_viewed(self):\n+        \"\"\"\n+        Mark ticket notifications as viewed\n+        \"\"\"\n+        from database.models.employee_notification_model import EmployeeNotification\n+        EmployeeNotification.mark_notifications_by_reference_id_as_viewed(self.id)\ndiff --git a/chatbot_service/services/document_query/document_query_list_dialog.py b/chatbot_service/services/document_query/document_query_list_dialog.py\nindex b63276f..643b69a 100644\n--- a/chatbot_service/services/document_query/document_query_list_dialog.py\n+++ b/chatbot_service/services/document_query/document_query_list_dialog.py\n@@ -64,7 +64,7 @@ class DocumentQueryListDialog(AbstractDialog):\n         )\n         self.dialog_template = WhatsAppListMessage(\n             body=WhatsAppInteractiveBody(\n-                text=\"Select which query which query you would like to view.\",\n+                text=\"Select which query you would like to view.\",\n             ),\n             footer=WhatsAppInteractiveFooter(\n                 text=\"Tap on the menu below to view them.\"\ndiff --git a/chatbot_service/services/employee_leave/employee_leave_list_dialog.py b/chatbot_service/services/employee_leave/employee_leave_list_dialog.py\nindex 3c1b074..3695ae9 100644\n--- a/chatbot_service/services/employee_leave/employee_leave_list_dialog.py\n+++ b/chatbot_service/services/employee_leave/employee_leave_list_dialog.py\n@@ -52,8 +52,8 @@ class EmployeeLeaveListDialog(AbstractDialog):\n             interactive_buttons.append(\n                 WhatsAppInteractiveSectionRow(\n                     id=f\"employeeTicket:{index + 1}\",\n-                    title=f\"{ticket.query_type} ({ticket.status.value.title()})\"[:24], # Meta characters have a limit of 24 characters\n-                    description=f\"Submitted on {ticket.date_created.strftime(\\'%d %b %Y\\')}\"[:72] # Meta characters have a limit of 72 characters\n+                    title=ticket.query_type[:24], # Meta characters have a limit of 24 characters\n+                    description=f\"{ticket.status.value.title()} / Submitted on {ticket.date_created.strftime(\\'%d %b %Y\\')}\"[:72] # Meta characters have a limit of 72 characters, This will need to be changed to show date range \n                 )\n             )\n         interactive_buttons.append(\ndiff --git a/chatbot_service/utils/employee_ticket_abstract_dialog.py b/chatbot_service/utils/employee_ticket_abstract_dialog.py\nindex 019e386..b4f2421 100644\n--- a/chatbot_service/utils/employee_ticket_abstract_dialog.py\n+++ b/chatbot_service/utils/employee_ticket_abstract_dialog.py\n@@ -14,6 +14,7 @@ class EmployeeTicketAbstractDialog(EmployeeNotificationAbstractDialog):\n \n         self.employee_ticket_id = self.user_session.get(\"meta_data\", {}).get(\"employee_ticket_id\", None)\n         self.employee_ticket = None\n+        self.ticket_details = None # Initialize to None\n         self.message_body = ( # Default message if no ticket details are found, and not implemented in child class\n             \"â\\x9a\\xa0ï¸\\x8f Unfortunately we experienced an error while retrieving your request.\"\n             \"\\nPlease try again later\"\n@@ -24,8 +25,11 @@ class EmployeeTicketAbstractDialog(EmployeeNotificationAbstractDialog):\n         elif self.employee_notification and isinstance(self.employee_notification.instance(), EmployeeTicket):\n             self.employee_ticket = self.employee_notification.instance()\n \n+        if self.employee_ticket and not self.employee_notification:\n+            self.employee_ticket.mark_ticket_notifications_as_viewed()\n+\n         if self.employee_ticket:\n-            self.ticket_details = self.employee_ticket.get_details()\n+            self.ticket_details = self.employee_ticket.get_details() or {}\n         else:\n             self.logger.warning(\n                 \"EmployeeTicketAbstractDialog: No employee_ticket_id or employee_notification found for employee_ticket_id %s\",\ndiff --git a/tests/database/models/test_employee_notification_model.py b/tests/database/models/test_employee_notification_model.py\nindex 211997b..25e485a 100644\n--- a/tests/database/models/test_employee_notification_model.py\n+++ b/tests/database/models/test_employee_notification_model.py\n@@ -231,4 +231,76 @@ class TestChainedFilters:\n        assert results == expected\n        assert len(query.filter_by_calls) == 3\n        assert len(query.limit_calls) == 1\n-       assert len(query.order_by_calls) == 1\n\\ No newline at end of file\n+       assert len(query.order_by_calls) == 1\n+\n+class TestNotificationViewingOperations:\n+    @pytest.mark.parametrize(\"scenario\", [\n+        {\n+            \"name\": \"include_read_true\",\n+            \"include_read\": True,\n+            \"expected_unread_filter\": False\n+        },\n+        {\n+            \"name\": \"include_read_false\",\n+            \"include_read\": False,\n+            \"expected_unread_filter\": True\n+        }\n+    ])\n+    def test_get_notifications_by_reference_id(self, db, scenario):\n+        # Arrange\n+        query = db.query.return_value\n+        expected_notifications = [Mock(), Mock()]\n+        query.set_results(expected_notifications)\n+        reference_id = \"test_ref_123\"\n+\n+        # Act\n+        result = EmployeeNotification.get_notifications_by_reference_id(\n+            reference_id=reference_id,\n+            include_read=scenario[\"include_read\"]\n+        )\n+\n+        # Assert\n+        assert result == expected_notifications\n+        filter_calls = query.filter_by_calls\n+        assert {\"reference_id\": reference_id} in filter_calls\n+        if scenario[\"expected_unread_filter\"]:\n+            assert {\"date_notification_viewed\": None} in filter_calls\n+\n+    @pytest.mark.parametrize(\"scenario\", [\n+        {\n+            \"name\": \"with_unread_notifications\",\n+            \"notifications\": [Mock(), Mock()],\n+            \"expected_commits\": 1\n+        },\n+        {\n+            \"name\": \"no_unread_notifications\",\n+            \"notifications\": [],\n+            \"expected_commits\": 0\n+        }\n+    ])\n+    def test_mark_notifications_by_reference_id_as_viewed(self, db, scenario):\n+        # Arrange\n+        query = db.query.return_value\n+        query.set_results(scenario[\"notifications\"])\n+        reference_id = \"test_ref_123\"\n+        mock_time = datetime(2025, 1, 1, 12, 0)\n+\n+        with patch(\\'chatbot_service.database.models.employee_notification_model.get_current_utc_time\\') as mock_time_fn:\n+            mock_time_fn.return_value = mock_time\n+\n+            # Act\n+            EmployeeNotification.mark_notifications_by_reference_id_as_viewed(reference_id)\n+\n+            # Assert\n+            filter_calls = query.filter_by_calls\n+            assert {\"reference_id\": reference_id} in filter_calls\n+            assert {\"date_notification_viewed\": None} in filter_calls\n+\n+            if scenario[\"notifications\"]:\n+                for notification in scenario[\"notifications\"]:\n+                    assert notification.date_notification_viewed == mock_time\n+                db.add_all.assert_called_once_with(scenario[\"notifications\"])\n+                assert db.commit.call_count == scenario[\"expected_commits\"]\n+            else:\n+                db.add_all.assert_not_called()\n+                assert db.commit.call_count == scenario[\"expected_commits\"]\n"
#
#     tool = GetListOfChangedFilesFromDiff(bitbucket_diff=diff_string)
#     print(tool.run())

